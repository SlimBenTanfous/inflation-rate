{
    "collab_server" : "",
    "contents" : "if(!require(shinydashboard)) { install.packages(\"shinydashboard\"); require(shinydashboard)}\nif(!require(shinyBS)) { devtools::install_github(\"AnalytixWare/ShinySky\"); require(shinyBS)}\nif(!require(shinyjs)) { install.packages(\"shinyjs\"); require(shinyjs)}\nif(!require(shiny)) { install.packages(\"shiny\"); require(shiny)}\nif(!require(shinysky)) { install.packages(\"shinysky\"); require(shinysky)}\nif(!require(gdata)) { install.packages(\"gdata\"); require(gdata)}\nif(!require(data.table)) { install.packages(\"data.table\"); require(data.table)}\nif(!require(ggvis)) { install.packages(\"ggvis\"); require(ggvis)}\nif(!require(dtplyr)) { install.packages(\"dtplyr\"); require(dtplyr)}\nif(!require(rhandsontable)) { install.packages(\"rhandsontable\"); require(rhandsontable)}\nif(!require(nlstools)) { install.packages(\"nlstools\"); require(nlstools)}\nif(!require(drc)) { install.packages(\"drc\"); require(drc)}\nif(!require(DT)) { install.packages(\"DT\"); require(DT)}\nif(!require(plotly)) { install.packages(\"plotly\"); require(plotly)}\nif(!require(corrplot)) { install.packages(\"corrplot\"); require(corrplot)}\nif(!require(ggfortify)) { install.packages(\"ggfortify\"); require(ggfortify)}\nif(!require(ClustOfVar)) { install.packages(\"ClustOfVar\"); require(ClustOfVar)}\nif(!require(splitstackshape)) { install.packages(\"splitstackshape\"); require(splitstackshape)}\nif(!require(dendextend)) { install.packages(\"dendextend\"); require(dendextend)}\nif(!require(cluster)) { install.packages(\"cluster\"); require(cluster)}\nif(!require(ggdendro)) { install.packages(\"ggdendro\"); require(ggdendro)}\nif(!require(tidyr)) { install.packages(\"tidyr\"); require(tidyr)}\nif(!require(factoextra)) { install.packages(\"factoextra\"); require(factoextra)}\nif(!require(FactoMineR)) { install.packages(\"FactoMineR\"); require(FactoMineR)}\nif(!require(vembedr)) { install.packages(\"vembedr\"); require(vembedr)}\nif(!require(htmltools)) { install.packages(\"htmltools\"); require(htmltools)}\n\nlibrary(gdata)\nlibrary(data.table)\nlibrary(ggvis)\nlibrary(dtplyr)\nlibrary(rhandsontable)\nlibrary(nlstools)\nlibrary(drc)\nlibrary(DT)\nlibrary(plotly)\nlibrary(corrplot)\nlibrary(ggfortify)\nlibrary(ClustOfVar)\nlibrary(splitstackshape)\nlibrary(dendextend)\nlibrary(cluster)\nlibrary(ggdendro)\nlibrary( tidyr)\nlibrary(factoextra)\nlibrary(FactoMineR)\nlibrary(vembedr)\nlibrary(htmltools)\n\nshinyServer(function(input, output,session) {\n  show(\"app-content\")\n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~BEGIN statistiques~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  datainrespl <- reactive({ \n    \n    inFile <- input$file3\n    if (is.null(inFile))\n      return(NULL)\n    Tabl=read.csv(inFile$datapath, header=input$header3, sep=input$sep3, \n                  quote=input$quote3)\n    \n    return(Tabl)\n  })\n  \n  \n  output$respldata = DT::renderDataTable({\n    \n    try(updateSelectInput(session, \"quantivar\",\"variable quantitative\", choices = names(df())))\n    try(updateSelectInput(session, \"qualivar\",\"variable qualitative\", choices = names(df1())))\n    \n    try(datatable(datainrespl(),  class = 'cell-border stripe',caption = 'Votre DATA',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n      \n      columnDefs = list(list(className = 'dt-center')),\n      buttons = \n        list('copy', 'print', list(\n          extend = 'collection',\n          buttons = c('csv', 'excel', 'pdf'),\n          text = 'Download'\n        )),\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n        \"}\"),\n      colReorder = TRUE\n    )\n    ))\n  })  \n  \n  observeEvent(input$file3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Visualisation Data\" = \"Data Upload\",\n                      \"Resume\"= \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  \n  \n  observeEvent(input$quote3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Visualisation Data\" = \"Data Upload\",\n                      \"Resume\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  observeEvent(input$sep3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Visualisation Data\" = \"Data Upload\",\n                      \"Resume\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  df = reactive({\n    \n    upload.data = data.frame(datainrespl())\n    \n    df = data.frame(0)\n    nn = \"x1\"\n    df1 = data.frame(0)\n    nn1 = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (is.numeric(upload.data[,i])){\n      df = try(data.frame(df,upload.data[,i]))\n      nn = try(c(nn, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df)=nn\n    df = df[-1]\n    \n    df\n  })\n  \n  df1 = reactive({\n    upload.data = data.frame(datainrespl())\n    \n    df1 = data.frame(0)\n    nn1 = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (!is.numeric(upload.data[,i])){\n      \n      df1 = try(data.frame(df1,upload.data[,i]))\n      nn1 = try(c(nn1, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df1)=nn1\n    df1 = df1[-1]\n    \n    df1\n  })\n  observeEvent(input$file3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Visualistion Data\"= \"Data Upload\",\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Resume\" = \"Data Upload\",\n                      \"Documentation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  \n  observeEvent(input$quote3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Visualistion Data\"= \"Data Upload\",\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Resume\" = \"Data Upload\",\n                      \"Documentation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  observeEvent(input$sep3,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Visualistion Data\"= \"Data Upload\",\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Resume\" = \"Data Upload\",\n                      \"Documentation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n  })\n  \n  observeEvent( input$sbmitrespl,{ \n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$resplpan,\n                      \"Methode d'utilisation\" = \"Resume\",\n                      \"Visualistion Data\"= \"Resume\",\n                      \"Methode d'utilisation\" = \"Resume\",\n                      \"Data Upload\"=\"Resume\"\n    )\n    \n    updateTabItems(session,\"resplpan\",restab11)\n    \n    if(input$quantivar==\"\"){\n      toggleModal(session, \"emptyrespl\", toggle =\"close\")\n    }else{\n      \n      output$summ = renderPrint({\n        summary(datainrespl())\n      })\n      \n      output$box = renderPlot({\n        \n        data.up = data.frame(datainrespl())\n        if(input$dtvis == \"BoxPlot\"){\n          p<-ggplot(data = data.up, aes(x=data.up[,input$qualivar], y=data.up[,input$quantivar], fill=data.up[,input$qualivar])) +\n            geom_boxplot()+\n            labs(x=input$qualivar, y = input$quantivar)+\n            ggtitle(paste(\"Plot de\",input$quantivar,\"par\",input$qualivar)) + \n            theme(plot.title = element_text(lineheight=.8, face=\"bold\"),legend.title = element_blank())\n          \n          \n        }else if(input$dtvis == \"ViolinPlot\"){\n          p<-ggplot(data = data.up, aes(x=data.up[,input$qualivar], y=data.up[,input$quantivar], fill=data.up[,input$qualivar])) +\n            geom_violin()+\n            labs(x=input$qualivar, y = input$quantivar)+\n            ggtitle(paste(\"Plot de\",input$quantivar,\"par\",input$qualivar)) + \n            theme(plot.title = element_text(lineheight=.8, face=\"bold\"),legend.title = element_blank())\n          \n          \n        }else if(input$dtvis == \"BarPlot\"){\n          p<-ggplot(data = data.up, aes(x=data.up[,input$qualivar], y=data.up[,input$quantivar], fill=data.up[,input$qualivar])) +\n            geom_bar(stat=\"identity\")+\n            labs(x=input$qualivar, y = input$quantivar)+\n            ggtitle(paste(\"Plot de\",input$quantivar,\"par\",input$qualivar)) + \n            theme(plot.title = element_text(lineheight=.8, face=\"bold\"),legend.title = element_blank())\n          \n          \n        }else if(input$dtvis == \"Cammembert\"){\n          bp<- ggplot(data = data.up, aes(x=\"\", y=data.up[,input$quantivar], fill=data.up[,input$qualivar]))+\n            geom_bar(width = 1, stat = \"identity\")+\n            labs(x=input$qualivar, y = input$quantivar)+\n            ggtitle(paste(\"Plot de\",input$quantivar,\"par\",input$qualivar)) + \n            theme(plot.title = element_text(lineheight=.8, face=\"bold\"),legend.title = element_blank())\n          p <- bp + coord_polar(\"y\", start=0)\n          \n          \n        }\n        \n        output$foo = downloadHandler(\n          filename = 'test.png',\n          content = function(file) {\n            device <- function(..., width, height) {\n              grDevices::png(..., width = width, height = height,\n                             res = 300, units = \"in\")\n            }\n            ggsave(file, plot = p, device = device)\n          })\n        p\n      })\n    }\n    withProgress(message = 'Chargement en cours ...',\n                 value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.1)\n                   }\n                   \n                 })\n  })\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END statistiques~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~BEGIN ACP~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  datainacp <- reactive({ \n    \n    inFile <- input$file4\n    if (is.null(inFile))\n      return(NULL)\n    Tabl=read.csv(inFile$datapath, header=input$header4, sep=input$sep4, \n                  quote=input$quote4)\n    \n    return(Tabl)\n  })\n  \n  \n  output$acpdata = DT::renderDataTable({\n    try(updateSelectInput(session, \"quantivaracp\",\"quanti.sup\", choices = names(dfacp())))\n    try(updateSelectInput(session, \"qualivaracp\",\"quali.sup\", choices = names(dfacp1()),selected = names(dfacp1())))\n    try(updateSelectInput(session, \"grp\",\"Groupe\", choices = names(dfacp1())))\n    \n    try(datatable(datainacp(),  class = 'cell-border stripe',caption = 'Votre DATA',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n      \n      columnDefs = list(list(className = 'dt-center')),\n      buttons = \n        list('copy', 'print', list(\n          extend = 'collection',\n          buttons = c('csv', 'excel', 'pdf'),\n          text = 'Download'\n        )),\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n        \"}\"),\n      colReorder = TRUE\n    )\n    ))\n  })  \n  \n  observeEvent(input$file4,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$acppan,\n                      \"Documentation\" = \"Data Upload\",\n                      \"Valeurs propres\" = \"Data Upload\",\n                      \"Correlation\" = \"Data Upload\",\n                      \"Courbe d'individus\" = \"Data Upload\",\n                      \"Cercle de correlation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"acppan\",restab11)\n    \n  })\n  \n  \n  observeEvent(input$quote4,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$acppan,\n                      \"Documentation\" = \"Data Upload\",\n                      \"Valeurs propres\" = \"Data Upload\",\n                      \"Correlation\" = \"Data Upload\",\n                      \"Courbe d'individus\" = \"Data Upload\",\n                      \"Cercle de correlation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"acppan\",restab11)\n    \n  })\n  \n  observeEvent(input$sep4,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$acppan,\n                      \"Documentation\" = \"Data Upload\",\n                      \"Valeurs propres\" = \"Data Upload\",\n                      \"Correlation\" = \"Data Upload\",\n                      \"Courbe d'individus\" = \"Data Upload\",\n                      \"Cercle de correlation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"acppan\",restab11)\n    \n  })\n  \n  dfacp = reactive({\n    \n    upload.data = data.frame(datainacp())\n    \n    df = data.frame(0)\n    nn = \"x1\"\n    df1 = data.frame(0)\n    nn1 = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (is.numeric(upload.data[,i])){\n      df = try(data.frame(df,upload.data[,i]))\n      nn = try(c(nn, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df)=nn\n    df = df[-1]\n    \n    df\n  })\n  \n  dfacp1 = reactive({\n    upload.data = data.frame(datainacp())\n    \n    df1 = data.frame(0)\n    nn1 = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (!is.numeric(upload.data[,i])){\n      \n      df1 = try(data.frame(df1,upload.data[,i]))\n      nn1 = try(c(nn1, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df1)=nn1\n    df1 = df1[-1]\n    \n    df1\n  })\n  \n  \n  \n  observeEvent(input$sbmitacp,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$acppan,\n                      \"Documentation\" = \"Valeurs propres\",\n                      \"Data Upload\" = \"Valeurs propres\",\n                      \"Correlation\" = \"Valeurs propres\",\n                      \"Courbe d'individus\" = \"Valeurs propres\",\n                      \"Cercle de correlation\" = \"Valeurs propres\"\n    )\n    \n    updateTabItems(session,\"acppan\",restab11)\n    \n    output$valp = renderPrint({\n      c = input$quantivaracp\n      d = input$qualivaracp\n      h = matrix(0,1,length(input$quantivaracp))\n      g = matrix(0,1,length(input$qualivaracp))\n      \n      colnames(h)=c\n      colnames(g)=d\n      for( i in 1:length(h))\n      {\n        h[,c[i]]=which(names(datainacp())==c[i])\n      }\n      for( i in 1:length(g))\n      {\n        g[,d[i]]=which(names(datainacp())==d[i])\n      }\n      \n      f = as.vector(h[1,]) \n      f1 = as.vector(g[1,])\n      \n      if(length(which(colnames(datainacp()) == input$quantivaracp))==0){\n        res.pca <- try(PCA(data.frame(datainacp()),scale.unit = T,quanti.sup =NULL,quali.sup =f1 ,ncp=input$ncp, graph = FALSE))\n      }else{\n        res.pca <- try(PCA(data.frame(datainacp()),scale.unit = T,quanti.sup = f ,quali.sup =f1 ,ncp=input$ncp, graph = FALSE))\n        \n      }\n      if(class(res.pca) == \"try-error\" || ncol(df())<1){\n        toggleModal(session, \"emptyacp\", toggle =\"close\")\n        return()\n      }else{\n        eig.val <- get_eigenvalue(res.pca)\n        var <- get_pca_var(res.pca)\n        \n        \n        output$ebl = renderPlot({\n          \n          p = fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))+\n            ggtitle(\"ébouli des valeurs propres\")\n          output$vlp = downloadHandler(\n            filename = 'valeurs propres.png',\n            content = function(file) {\n              device <- function(..., width, height) {\n                grDevices::png(..., width = width, height = height,\n                               res = 300, units = \"in\")\n              }\n              ggsave(file, plot = p, device = device)\n            })\n          p\n        })\n        \n        eig.val\n      }\n    })\n    \n    output$cor2 = renderPlot({\n      \n      c = input$quantivaracp\n      d = input$qualivaracp\n      h = matrix(0,1,length(input$quantivaracp))\n      g = matrix(0,1,length(input$qualivaracp))\n      \n      colnames(h)=c\n      colnames(g)=d\n      for( i in 1:length(h))\n      {\n        h[,c[i]]=which(names(datainacp())==c[i])\n      }\n      for( i in 1:length(g))\n      {\n        g[,d[i]]=which(names(datainacp())==d[i])\n      }\n      \n      f = as.vector(h[1,]) \n      f1 = as.vector(g[1,])\n      \n      if(length(which(colnames(datainacp()) == input$quantivaracp))==0){\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup =NULL,quali.sup =f1 , ncp=input$ncp,graph = FALSE)\n      }else{\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup = f ,quali.sup =f1 ,ncp=input$ncp, graph = FALSE)\n        \n      }\n      eig.val <- get_eigenvalue(res.pca)\n      var <- get_pca_var(res.pca)\n      output$cor22 = renderPrint({\n        head(var$contrib)\n      })\n      corrplot(var$cos2, is.corr=FALSE)\n    })\n    \n    output$cos = renderPlot({\n      c = input$quantivaracp\n      d = input$qualivaracp\n      h = matrix(0,1,length(input$quantivaracp))\n      g = matrix(0,1,length(input$qualivaracp))\n      \n      colnames(h)=c\n      colnames(g)=d\n      for( i in 1:length(h))\n      {\n        h[,c[i]]=which(names(datainacp())==c[i])\n      }\n      for( i in 1:length(g))\n      {\n        g[,d[i]]=which(names(datainacp())==d[i])\n      }\n      \n      f = as.vector(h[1,]) \n      f1 = as.vector(g[1,])\n      \n      if(length(which(colnames(datainacp()) == input$quantivaracp))==0){\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup =NULL,quali.sup =f1 ,ncp=input$ncp, graph = FALSE)\n      }else{\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup = f ,quali.sup =f1 ,ncp=input$ncp, graph = FALSE)\n        \n      }\n      eig.val <- get_eigenvalue(res.pca)\n      var <- get_pca_var(res.pca)\n      fviz_cos2(res.pca, choice = \"var\", axes = 1:2)\n    })\n    \n    output$crb = renderPlot({\n      c = input$quantivaracp\n      d = input$qualivaracp\n      h = matrix(0,1,length(input$quantivaracp))\n      g = matrix(0,1,length(input$qualivaracp))\n      \n      colnames(h)=c\n      colnames(g)=d\n      for( i in 1:length(h))\n      {\n        h[,c[i]]=which(names(datainacp())==c[i])\n      }\n      for( i in 1:length(g))\n      {\n        g[,d[i]]=which(names(datainacp())==d[i])\n      }\n      \n      f = as.vector(h[1,]) \n      f1 = as.vector(g[1,])\n      \n      if(length(which(colnames(datainacp()) == input$quantivaracp))==0){\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup =NULL,quali.sup =f1 ,ncp=input$ncp, graph = FALSE)\n      }else{\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup = f ,quali.sup =f1 , ncp=input$ncp,graph = FALSE)\n        \n      }\n      \n      if(input$elip == \"oui\"){\n        p = fviz_pca_ind (res.pca, geom.ind = \"point\", # Montre les points seulement (mais pas le \"text\")\n                          col.ind = data.frame(datainacp())[,input$grp],addEllipses = TRUE,legend.title = \"Groupes\"\n        )+ggtitle(\"Courbe d'individus\")\n        \n        \n      }else if(input$elip == \"non\"){\n        p= fviz_pca_ind (res.pca, geom.ind = \"point\", # Montre les points seulement (mais pas le \"text\")\n                         col.ind = data.frame(datainacp())[,input$grp],addEllipses = F,legend.title = \"Groupes\")+\n          ggtitle(\"Courbe d'individus\")\n        \n      }\n      \n      \n      output$crbind = downloadHandler(\n        filename = \"courbe d'individus.png\",\n        content = function(file) {\n          device <- function(..., width, height) {\n            grDevices::png(..., width = width, height = height,\n                           res = 300, units = \"in\")\n          }\n          ggsave(file, plot = p, device = device)\n        })\n      p\n    })\n    \n    output$cercle = renderPlot({\n      c = input$quantivaracp\n      d = input$qualivaracp\n      h = matrix(0,1,length(input$quantivaracp))\n      g = matrix(0,1,length(input$qualivaracp))\n      \n      colnames(h)=c\n      colnames(g)=d\n      for( i in 1:length(h))\n      {\n        h[,c[i]]=which(names(datainacp())==c[i])\n      }\n      for( i in 1:length(g))\n      {\n        g[,d[i]]=which(names(datainacp())==d[i])\n      }\n      \n      f = as.vector(h[1,]) \n      f1 = as.vector(g[1,])\n      \n      if(length(which(colnames(datainacp()) == input$quantivaracp))==0){\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup =NULL,quali.sup =f1 ,ncp=input$ncp, graph = FALSE)\n      }else{\n        res.pca <- PCA(data.frame(datainacp()),scale.unit = T,quanti.sup = f ,quali.sup =f1 , ncp=input$ncp,graph = FALSE)\n        \n      }\n      p = fviz_pca_var(res.pca, col.var = \"cos2\",\n                       repel = TRUE # Évite le chevauchement de texte\n      )+ggtitle(\"Cercle de corrélation\")\n      \n      output$crc = downloadHandler(\n        filename = 'Cercle de corrélation.png',\n        content = function(file) {\n          device <- function(..., width, height) {\n            grDevices::png(..., width = width, height = height,\n                           res = 300, units = \"in\")\n          }\n          ggsave(file, plot = p, device = device)\n        })\n      p\n    })\n    withProgress(message = 'Chargement en cours ...',\n                 value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.1)\n                   }\n                   \n                 })\n  })\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END ACP~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~BEGIN Multiple linear regression~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  datainReg <- reactive({ \n    if(is.null(input$MLFdtup)){\n      toggleModal(session, \"emptyReg\", toggle =\"close\")\n      return()\n    }else if ( input$MLFdtup == 'File Upload') {\n      inFile <- input$file1\n      if(is.null(inFile))\n      { return(NULL)}\n      \n      #load file that was specified by user and save into a uploaded data frame\n      Tabl=read.csv(inFile$datapath, header=input$header, sep=input$sep, \n                    quote=input$quote)\n      \n    }\n    \n    return(Tabl)\n  })\n  \n  output$dataRegout = DT::renderDataTable({\n    upload.data = data.frame(datainReg())\n    df = data.frame(0)\n    nn = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (is.numeric(upload.data[,i])){\n      df = try(data.frame(df,upload.data[,i]))\n      nn = try(c(nn, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df)=nn\n    df = df[-1]\n    updateSelectInput(session, \"choose_columns1\", NULL, choices = names(df))\n    updateSelectInput(session, \"choose_columns2\", NULL, choices = names(df))\n    updateSelectInput(session, \"corval\", NULL, choices = names(df),selected = names(df))\n    \n    \n    datatable(datainReg(),  class = 'cell-border stripe',caption = 'Votre DATA',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n      \n      columnDefs = list(list(className = 'dt-center')),\n      buttons = \n        list('copy', 'print', list(\n          extend = 'collection',\n          buttons = c('csv', 'excel', 'pdf'),\n          text = 'Download'\n        )),\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n        \"}\"),\n      colReorder = TRUE\n    )\n    )\n  })     \n  \n  \n  \n  ############################################################\n  \n  observeEvent(input$MLFdtup,{\n    rm(list=ls())\n    environment= environment()\n    \n    \n    restab11 = switch(input$MLFres,\n                      \"Methode d'utilisation\" = \"Data Upload\",\n                      \"Resultats Statistiques\" = \"Data Upload\",\n                      \"Documentation\" = \"Data Upload\",\n                      \"Régression Plot3D\" = \"Data Upload\",\n                      \"Régression Plot2D\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"MLFres\",restab11)\n    \n    \n  })\n  \n  \n  observeEvent(input$sbmitReg ,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    restab12 = switch(input$MLFres,\n                      \"Methode d'utilisation\" = \"Resultats Statistiques\",\n                      \"Matrice de correlation\" = \"Resultats Statistiques\",\n                      \"Resultats Statistiques\" = \"Resultats Statistiques\",\n                      \"Data Upload\" = \"Resultats Statistiques\",\n                      \"Documentation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"MLFres\",restab12)\n    \n    \n    if(!is.null(input$MLFdtup)){\n      \n      if(all(datainReg()==\"\") || is.null(input$choose_columns2)){\n        toggleModal(session, \"emptyReg\", toggle =\"close\")\n      }\n      \n      output$correlation = renderPlot({\n        df = data.frame(datainReg())\n        if(input$mix == \"simple\"){\n          p = try(corrplot(cor(df[,c(input$corval)]),method = input$methode,type = input$type,order = input$order,addrect = input$order1))\n          if(class(p)==\"try-error\"){\n            return()\n          }else{return(p)}\n        }else if(input$mix == \"mixed\"){\n          p = try(corrplot.mixed(cor(df[,c(input$corval)]),lower = input$lower,upper = input$upper))\n          if(class(p)==\"try-error\"){\n            return()\n          }else{\n            \n            p\n          }\n        }\n        \n        \n      })\n      \n      dataReg <<- reactive({ \n        \n        df = data.frame(datainReg())\n        \n        y = which(colnames(df) == input$choose_columns1)\n        df1 = data.frame(df[y])\n        \n        x=matrix(0,1,length(input$choose_columns2))\n        for(i in 1:length(input$choose_columns2)){\n          x[1,i] = which(colnames(df) == input$choose_columns2[i])\n        }\n        for(i in 1:length(x)){\n          df1 = try(data.frame(df1,df[x[i]]))\n          if (class(df1) == \"try-error\"){\n            return(NULL)\n          }\n        }\n        \n        if(input$intercept1 == \"oui\")\n        {\n          mod = try(lm( df1[,1] ~ . ,df1[-1]))\n          \n        }else if(input$intercept1 == \"non\"){\n          mod = try(lm( df1[,1] ~ .-1 ,df1[-1]))\n          \n        }\n        dd = data.frame(coefficients(summary(mod)))\n        for(i in 1:nrow(dd)){\n          for(j in 1:ncol(dd)){\n            dd[i,j]=format(as.numeric(dd[i,j]),scientific = T)\n          }\n        }\n        \n        test = 1\n        for(i in 1:length(df1))\n        { if (is.numeric(df1[,i])){\n          test = test*1\n        }else{\n          test = test*0\n        }\n        }\n        if(test ==1){\n          return(dd)\n        }else{\n          \n          toggleModal(session, \"emptyReg\", toggle =\"close\")\n          return(NULL)\n        }\n        \n        \n        \n      })\n      \n      \n      \n      output$regStat = DT::renderDataTable({\n        datatable(dataReg(),  class = 'cell-border stripe',caption = 'Tableau statistisque des coefficients',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n          dom = 'Bt',\n          columnDefs = list(list(className = 'dt-center')),\n          buttons = \n            list('copy', 'print', list(\n              extend = 'collection',\n              buttons = c('csv', 'excel', 'pdf'),\n              text = 'Download'\n            )),\n          initComplete = JS(\n            \"function(settings, json) {\",\n            \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n            \"}\"),\n          colReorder = TRUE\n        )\n        )\n      })     \n      \n      dataReg1 <<- reactive({\n        \n        if(is.null(dataReg())){\n          return(NULL)\n        }else{\n          \n          df = data.frame(datainReg())\n          y = which(colnames(df) == input$choose_columns1)\n          df1 = data.frame(df[y])\n          \n          x=matrix(0,1,length(input$choose_columns2))\n          for(i in 1:length(input$choose_columns2)){\n            x[1,i] = which(colnames(df) == input$choose_columns2[i])\n          }\n          for(i in 1:length(x)){\n            df1 = data.frame(df1,df[x[i]])\n          }\n          if(input$intercept1 == \"oui\")\n          {\n            mod = try(lm( df1[,1] ~ . ,df1[-1]))\n            if (class(mod) == \"try-error\"){\n              \n              return(NULL)\n            }\n          }else if(input$intercept1 == \"non\"){\n            mod = try(lm( df1[,1] ~ .-1 ,df1[-1]))\n            if (class(mod) == \"try-error\"){\n              return(NULL)\n            }\n          }\n          \n          \n          \n          \n          \n          fdata = matrix(0,6,1)\n          \n          fdata[1,1]=format(as.numeric(glance(mod)$sigma),scientific = T)\n          fdata[2,1]=format(as.numeric(glance(mod)$df.residual),scientific = T)\n          fdata[3,1]=format(as.numeric(glance(mod)$r.squared),scientific = T)\n          fdata[4,1]=format(as.numeric(glance(mod)$adj.r.squared),scientific = T)\n          fdata[5,1]=format(as.numeric(summary(mod)$fstatistic[1]),scientific = T)\n          fdata[6,1]=format(as.numeric(glance(mod)$p.value),scientific = T)\n          \n          fdata = data.frame(fdata)\n          \n          row.names(fdata)[1] = \"Residual  Standard Error\"\n          row.names(fdata)[2] = \"Degrees of Freedom\"\n          row.names(fdata)[3] =\"R-squared\"\n          row.names(fdata)[4] =\"Adjusted R-squared\"\n          row.names(fdata)[5] =\"F-statistic\"\n          row.names(fdata)[6] =\"p-value\"\n          \n          colnames(fdata) = \"Valeurs\"\n          \n          fdata\n        }}\n        \n      )\n      \n      output$regStat1 = DT::renderDataTable({\n        dda1 = try(datatable(dataReg1(),  class = 'cell-border stripe',caption = 'Plus de Statistiques',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n          dom = 'Bt',\n          columnDefs = list(list(className = 'dt-center')),\n          buttons = \n            list('copy', 'print', list(\n              extend = 'collection',\n              buttons = c('csv', 'excel', 'pdf'),\n              text = 'Download'\n            )),\n          initComplete = JS(\n            \"function(settings, json) {\",\n            \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n            \"}\"),\n          colReorder = TRUE\n        )\n        ))\n        if (class(dda1) == \"try-error\"){\n          return()\n        }else{return(dda1)}\n      })     \n      \n      \n      \n      \n      dataReg2 <<- reactive({ \n        \n        if(is.null(dataReg())){\n          return(NULL)\n        }else{\n          df = data.frame(datainReg())\n          \n          y = which(colnames(df) == input$choose_columns1)\n          df1 = data.frame(df[y])\n          \n          x=matrix(0,1,length(input$choose_columns2))\n          for(i in 1:length(input$choose_columns2)){\n            x[1,i] = which(colnames(df) == input$choose_columns2[i])\n          }\n          for(i in 1:length(x)){\n            df1 = try(data.frame(df1,df[x[i]]))\n            if (class(df1) == \"try-error\"){\n              return(NULL)\n            }\n          }\n          if(input$intercept1 == \"oui\")\n          {\n            mod = try(lm( df1[,1] ~ . ,df1[-1]))\n            \n          }else if(input$intercept1 == \"non\"){\n            mod = try(lm( df1[,1] ~ .-1 ,df1[-1]))\n            \n          }\n          dd = data.frame(confint(mod))\n          if(is.null(dataReg())){\n            return(null)\n          }else{\n            colnames(dd)[1]=\"2.5%\"\n            colnames(dd)[2]=\"97.5%\"\n            dd\n          }\n        }\n        \n        \n      })\n      \n      \n      output$regStat2 = DT::renderDataTable({\n        dda1 = try(datatable(dataReg2(),  class = 'cell-border stripe',caption = \"Intervalles de confiance\",  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n          dom = 'Bt',\n          columnDefs = list(list(className = 'dt-center')),\n          buttons = \n            list('copy', 'print', list(\n              extend = 'collection',\n              buttons = c('csv', 'excel', 'pdf'),\n              text = 'Download'\n            )),\n          initComplete = JS(\n            \"function(settings, json) {\",\n            \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n            \"}\"),\n          colReorder = TRUE\n        )\n        ))\n        if (class(dda1) == \"try-error\"){\n          return()\n        }else{return(dda1)}\n      })     \n      \n      dataReg3 <<- reactive({ \n        \n        if(is.null(dataReg())){\n          return(NULL)\n        }else{ \n          \n          df = data.frame(datainReg())\n          \n          y = which(colnames(df) == input$choose_columns1)\n          \n          df1 = data.frame(df[y])\n          \n          x=matrix(0,1,length(input$choose_columns2))\n          for(i in 1:length(input$choose_columns2)){\n            x[1,i] = which(colnames(df) == input$choose_columns2[i])\n          }\n          for(i in 1:length(x)){\n            df1 = try(data.frame(df1,df[x[i]]))\n            if (class(df1) == \"try-error\"){\n              return(NULL)\n            }\n          }\n          if(input$intercept1 == \"oui\")\n          {\n            mod = try(lm( df1[,1] ~ . ,df1[-1]))\n            \n          }else if(input$intercept1 == \"non\"){\n            mod = try(lm( df1[,1] ~ .-1 ,df1[-1]))\n            \n          }\n          dd = data.frame(anova(mod))\n          if(is.null(dataReg())){\n            return(null)\n          }else{\n            colnames(dd)[1]=\"DF\"\n            colnames(dd)[2]=\"somme des carrés\"\n            colnames(dd)[3]=\"moyenne des carrés\"\n            colnames(dd)[4]=\"statistique de Fisher\"\n            colnames(dd)[5]=\"Pr(>F)\"\n            dd\n          }\n        }\n      })\n      \n      output$regStat3 = DT::renderDataTable({\n        dda1 = try(datatable(dataReg3(),  class = 'cell-border stripe',caption = \"Analyse de la variance\",  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n          dom = 'Bt',\n          columnDefs = list(list(className = 'dt-center')),\n          buttons = \n            list('copy', 'print', list(\n              extend = 'collection',\n              buttons = c('csv', 'excel', 'pdf'),\n              text = 'Download'\n            )),\n          initComplete = JS(\n            \"function(settings, json) {\",\n            \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n            \"}\"),\n          colReorder = TRUE\n        )\n        ))\n        if (class(dda1) == \"try-error\"){\n          return()\n        }else{return(dda1)}\n      })   \n      \n      \n      \n      \n      Lr.df <- reactive({ \n        \n        df = data.frame(datainReg())\n        \n        y = which(colnames(df) == input$choose_columns1)\n        df1 = data.frame(df[y])\n        \n        x=matrix(0,1,1)\n        if(length(input$choose_columns2) == 1){\n          x[1,1] = which(colnames(df) == input$choose_columns2[1])\n          df1 = try(data.frame(df1,df[x[1]]))\n          if(class(df1)==\"try-error\"){\n            \n            df1 = data.frame(0,0)\n            \n          }else{\n            colnames(df1)[1]=\"y\"  \n            colnames(df1)[2]=\"x\" \n            \n          }\n          \n        }else{\n          df1 = try(data.frame(0,0))\n          colnames(df1)[1]=\"y\"  \n          colnames(df1)[2]=\"x\" \n          \n        }\n        \n        if(is.numeric(df1[,1]) & is.numeric(df1[,2])){\n          df1\n          \n        }else{\n          df1 = try(data.frame(0,0))\n          colnames(df1)[1]=\"y\"  \n          colnames(df1)[2]=\"x\" \n          df1\n        }\n        \n        \n      })\n      \n      colorcurve <<- \"yellow\"\n      if(is.null(input$col)){\n        return()\n      }else{\n        colorcurve<<- as.factor(input$col)\n      }\n      colorpts <<- \"yellow\"\n      if(is.null(input$ptcol)){\n        return()\n      }else{\n        colorpts<<- as.factor(input$ptcol)\n      }\n      visPR <- try(reactive({\n        p = try(data.frame(Lr.df()) %>% ggvis(~x, ~y) %>%\n                  \n                  layer_model_predictions(model = \"lm\",se= TRUE,stroke := colorcurve, fill := \"#ff0066\")%>%\n                  layer_points(size := 50, size.hover := 200,\n                               fillOpacity := 1, fillOpacity.hover := 0.5,fill:=colorpts ) %>%\n                  add_axis(\"x\", title = input$choose_columns2) %>%\n                  add_axis(\"y\",title = input$choose_columns1 ) %>%\n                  \n                  add_axis(\"x\", orient = \"top\", ticks = 0, title = input$mtitle,\n                           properties = axis_props(\n                             axis = list(stroke = \"white\"),\n                             labels = list(fontSize = 15),\n                             title= list(fontSize =input$mtitlesize)))%>%\n                  set_options(width = \"auto\")\n                \n                \n        )\n        if(class(p)==\"try-error\"){\n          df = matrix(0,1,2)\n          df = data.frame(df)\n          colnames(df)[1]=\"y\"\n          colnames(df)[2]=\"x\"\n          p = df%>% ggvis(~x, ~y)\n          \n          p\n        }else{\n          return(p)\n        }\n      }))\n      p = try(visPR %>% bind_shiny(\"plot2\"))\n      if(class(p)==\"try-error\"){\n        output$plot2 = renderGvis({df = matrix(0,1,2)\n        df = data.frame(df)\n        colnames(df)[1]=\"y\"\n        colnames(df)[2]=\"x\"\n        p = df%>% ggvis(~x, ~y)\n        \n        p})\n      }else{\n        p\n      }\n      \n      \n      colorcurve1 <<- \"yellow\"\n      if(is.null(input$col1)){\n        return()\n      }else{\n        colorcurve1<<- as.factor(input$col1)\n      }\n      colorpts1 <<- \"yellow\"\n      if(is.null(input$ptcol1)){\n        return()\n      }else{\n        colorpts1<<- as.factor(input$ptcol1)\n      }\n      \n      output$plot3 = renderPlotly({\n        df = data.frame(datainReg())\n        \n        y = which(colnames(df) == input$choose_columns1)\n        \n        df1 = data.frame(df[y])\n        \n        x=matrix(0,1,2)\n        if(length(input$choose_columns2) == 2){\n          x[1,1] = which(colnames(df) == input$choose_columns2[1])\n          x[1,2] = which(colnames(df) == input$choose_columns2[2])\n          df1 = try(data.frame(df1,df[x[1]]))\n          df1 = try(data.frame(df1,df[x[2]])) \n          if(class(df1)==\"try-error\"){\n            df1 = matrix(0,1,3)\n            df1 =data.frame(df1)\n          }else{\n            colnames(df1)[1]=\"y\"  \n            colnames(df1)[2]=\"x1\"\n            colnames(df1)[3]=\"x2\"\n            \n          }\n          \n          l <- list(\n            font = list(\n              family = \"sans-serif\",\n              size = 12,\n              color = \"#000\"),\n            bgcolor = \"#E2E2E2\",\n            bordercolor = \"#FFFFFF\",\n            borderwidth = 2)\n          MLFY.df = data.frame(df1)\n          if(input$intercept1 == \"oui\"){\n            md=try(lm(y~x1+x2,MLFY.df))\n          }else if(input$intercept1 == \"non\"){\n            md=try(lm(y~x1+x2-1,MLFY.df))\n          }\n          y1=round(predict.lm(md),digits=2)\n          grad1 = seq(round(min(MLFY.df$x1),digits=2),round(max(MLFY.df$x1),digits=2),length.out = 7001)\n          grad2= seq(round(min(MLFY.df$x2),digits=2),round(max(MLFY.df$x2),digits=2),length.out = 7001)\n          grad3 = seq(min(y1),max(y1),length.out = 7001)\n          gradY.df=data.frame(grad1,grad2,grad3)\n          \n          \n          p = try(plot_ly()%>%\n                    add_trace(MLFY.df,x = ~round(MLFY.df$x1,digits=2), y = ~round(MLFY.df$x2,digits=2), z = ~round(MLFY.df$y,digits=2),name =paste(\"distribution de\",input$choose_columns2[1],\",\",input$choose_columns2[2],\"et\",input$choose_columns1), type = 'scatter3d',  mode = \"markers\", \n                              \n                              marker = list(size = 3.5, color = colorpts1 , colorscale = 'Greens', cmin = -20, cmax = 50))%>%\n                    \n                    add_trace(gradY.df,x = ~grad1, y = ~grad2, z = ~grad3, name = paste(\"l'alignement des valeurs du modèle\") ,type = 'scatter3d',mode = \"lines\", \n                              \n                              line = list(width = 6, color = colorcurve1, colorscale = 'Viridis'))%>% \n                    layout(legend = list(orientation = 'h'))%>% layout(legend = l)%>% \n                    \n                    layout(autosize = T,\n                           \n                           scene = list(\n                             xaxis = list(title = input$choose_columns2[1]),\n                             yaxis = list(title = input$choose_columns2[2]),\n                             zaxis = list(title = input$choose_columns1)\n                           ))\n                  \n          )\n          \n          \n          \n          if(class(p)==\"try-error\"){\n            MLFY.df = matrix(0,1,3)\n            MLFY.df = data.frame(MLFY.df)\n            colnames(MLFY.df)[1]=\"y\"\n            colnames(MLFY.df)[2]=\"x1\"\n            colnames(MLFY.df)[3]=\"x2\"\n            p=NULL\n            p\n            toggleModal(session, \"error3D\", toggle =\"close\")\n          }else{\n            return(p)\n          }\n          \n        }else{\n          \n          toggleModal(session, \"error3D\", toggle =\"close\")\n          return(NULL)\n        }\n        \n        \n        \n      })\n      \n      \n      \n      \n      \n    }else{\n      toggleModal(session, \"supplyMLF\", toggle =\"close\")\n      return()\n    }\n    \n    withProgress(message = 'Chargement en cours ...',\n                 value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.1)\n                   }\n                   \n                 })\n    \n    \n    \n    \n    \n    \n  })\n  \n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END Multiple linear regression~~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Begin classification Test~~~~~~~~~~~~~~~~~~~~~~~~~~#\n  output$dataRegout1 = DT::renderDataTable({\n    datatable(datainReg1(),  class = 'cell-border stripe',caption = 'Votre DATA',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n      \n      columnDefs = list(list(className = 'dt-center')),\n      buttons = \n        list('copy', 'print', list(\n          extend = 'collection',\n          buttons = c('csv', 'excel', 'pdf'),\n          text = 'Download'\n        )),\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n        \"}\"),\n      colReorder = TRUE\n    )\n    )\n  })     \n  \n  datainReg1 <- reactive({ \n    if(is.null(input$fildtp)){\n      return()\n    }else if ( input$fildtp == 'File Upload') {\n      inFile <- input$file2\n      if(is.null(inFile))\n      { return(NULL)}\n      \n      #load file that was specified by user and save into a uploaded data frame\n      Tabl=read.csv(inFile$datapath, header=input$header2, sep=input$sep2, \n                    quote=input$quote2)\n      \n    }\n    \n    return(Tabl)\n  })\n  \n  \n  output$percent = renderUI({\n    prgoressBar <- function(value = 0, label = FALSE, color = \"aqua\", size = NULL,\n                            striped = FALSE, active = FALSE, vertical = FALSE) {\n      stopifnot(is.numeric(value))\n      if (value < 0 || value > 100)\n        stop(\"'value' should be in the range from 0 to 100.\", call. = FALSE)\n      if (!(color %in% shinydashboard:::validColors || color %in% shinydashboard:::validStatuses))\n        stop(\"'color' should be a valid status or color.\", call. = FALSE)\n      if (!is.null(size))\n        size <- match.arg(size, c(\"sm\", \"xs\", \"xxs\"))\n      text_value <- paste0(value, \"%\")\n      if (vertical)\n        style <- htmltools::css(height = text_value, `min-height` = \"2em\")\n      else\n        style <- htmltools::css(width = text_value, `min-width` = \"2em\")\n      tags$div(\n        class = \"progress\",\n        class = if (!is.null(size)) paste0(\"progress-\", size),\n        class = if (vertical) \"vertical\",\n        class = if (active) \"active\",\n        tags$div(\n          class = \"progress-bar\",\n          class = paste0(\"progress-bar-\", color),\n          class = if (striped) \"progress-bar-striped\",\n          style = style,\n          role = \"progressbar\",\n          `aria-valuenow` = value,\n          `aria-valuemin` = 0,\n          `aria-valuemax` = 100,\n          tags$span(class = if (!label) \"sr-only\", text_value)\n        )\n      )\n    }\n    \n    prgoressBar(value = input$tau, label = T, color = \"aqua\", size = NULL,\n                striped = FALSE, active = T, vertical = FALSE)\n    \n    \n  })\n  \n  \n  observeEvent(input$stepTOW,{\n    nextab = switch(input$classdt,\n                    \"Classification\" = \"Echantillonage\"\n    )\n    updateTabItems(session,\"classdt\",nextab)\n  } )\n  observeEvent(input$stepONEbkw,{\n    nextab = switch(input$classdt,\n                    \"Echantillonage\" = \"Classification\"  \n    )\n    updateTabItems(session,\"classdt\",nextab)\n  })\n  \n  koptimal<-function(data.input,n,tau,kmin,kmax,meth.class,meth.ech){\n    \n    for(i in 1:length(rownames(data.input))){\n      data = data.input\n      rownames(data)[i] = i\n    }\n    \n    if(meth.ech ==\"Sans remise\"){\n      ech_sans_remise=function(data,gamma){\n        echantillon=sample(1:nrow(data),gamma*nrow(data),replace=F)\n        echantillon=sort(echantillon)\n        return(echantillon)\n      }\n      nblinessample = matrix(0,n,tau*nrow(data))\n      for (i in 1:n){\n        nblinessample [i,] = as.integer(ech_sans_remise(data,tau))\n      }\n      \n    }else if(meth.ech ==\"Avec remise\"){\n      ech_avec_remise=function(data,gamma){\n        echantillon=sample(1:nrow(data),gamma*nrow(data),replace=T)\n        echantillon=sort(echantillon)\n        return(echantillon)\n      }\n      nblinessample = matrix(0,n,tau*nrow(data))\n      for (i in 1:n){\n        nblinessample [i,] = as.integer(ech_avec_remise(data,tau))\n      }\n      \n    }else if(meth.ech ==\"Stratifiée\"){\n      ech_strat=function(data,gamma){\n        mm = c(1:nrow(data))\n        ech = data.frame(data,mm)\n        echantillon = stratified(ech,c(1), gamma)\n        echantillon = as.data.frame(echantillon)\n        a = echantillon[,length(echantillon)]\n        a = sort(a)\n        return(a)\n      }\n      \n      \n      nblinessample = matrix(0,n,length(ech_strat(data,tau)))\n      for (i in 1:n){\n        nblinessample [i,] = as.integer(ech_strat(data,tau))\n      }\n    }\n    \n    \n    moyenneRandmat = matrix(0,1,kmax)\n    moyenneRandmat = as.data.frame(moyenneRandmat)\n    rownames(moyenneRandmat) <- c(\"moyennes des indices de Rand\")\n    \n    for(i in 1 : kmax){\n      \n      colnames(moyenneRandmat)[i] = paste(\"k =\",i)\n    }\n    \n    moyenneRandmat1 = matrix(0,1,1)\n    rownames(moyenneRandmat1) <- c(\"selon les indices de Rand\")\n    colnames(moyenneRandmat1) = c(\"K optimal\")\n    \n    moyenneRand = 0\n    \n    for(i in 1:kmax){\n      moyenneRand[i]=0\n    }\n    \n    if(meth.class==\"Kmeans\"){\n      \n      for(k in kmin:kmax){\n        \n        clusterpop = kmeans(data,k,nstart = 1)$cluster\n        moy = 0\n        \n        for(i in 1:n){\n          \n          echantillon= data[nblinessample[i,],]\n          clusterech = kmeans(echantillon,k,nstart = 20)$cluster\n          r = rand(clusterpop[nblinessample[i,]],clusterech)\n          \n          moy=(moy+(r/n))\n          \n        }\n        \n        moyenneRand[k]=moy\n        \n      }\n      \n      for(i in 1:kmax){ \n        \n        moyenneRandmat[1,i]=moyenneRand[i]\n        \n      }\n      \n      moyenneRandmat1[1,1] = which(moyenneRand==max(moyenneRand))[length( which(moyenneRand==max(moyenneRand)))]\n      \n    }else if(meth.class == \"Complète\"){\n      \n      for(k in kmin:kmax){\n        \n        clusterpop = hclust (dist (data),method = \"complete\")\n        moy = 0\n        \n        for(i in 1:n){\n          \n          echantillon= data[nblinessample[i,],]\n          clusterech = hclust (dist (echantillon),method = \"complete\")\n          r = rand(cutree(clusterpop,k)[nblinessample[i,]],cutree(clusterech,k))\n          \n          moy=(moy+(r/n))\n          \n        }\n        \n        moyenneRand[k]=moy\n        \n      }\n      \n      for(i in 1:kmax){ \n        \n        moyenneRandmat[1,i]=moyenneRand[i]\n        \n      }\n      \n      moyenneRandmat1[1,1] = which(moyenneRand==max(moyenneRand))[length( which(moyenneRand==max(moyenneRand)))]\n      \n    }else if(meth.class == \"Moyenne\"){\n      \n      for(k in kmin:kmax){\n        \n        clusterpop = hclust (dist (data),method = \"average\")\n        moy = 0\n        for(i in 1:n){\n          \n          echantillon= data[nblinessample[i,],]\n          clusterech = hclust (dist (echantillon),method = \"average\")\n          r = rand(cutree(clusterpop,k)[nblinessample[i,]],cutree(clusterech,k))\n          \n          moy=(moy+(r/n))\n          \n        }\n        \n        moyenneRand[k]=moy\n        \n      }\n      for(i in 1:kmax){ \n        \n        moyenneRandmat[1,i]=moyenneRand[i]\n        \n      }\n      \n      moyenneRandmat1[1,1] = which(moyenneRand==max(moyenneRand))[length( which(moyenneRand==max(moyenneRand)))]\n      \n    }else if(meth.class == \"Hiérarchique\"){\n      \n      for(k in kmin:kmax){\n        \n        clusterpop = hclust (dist (data),method = \"ward.D2\")\n        moy = 0\n        \n        for(i in 1:n){\n          \n          echantillon= data[nblinessample[i,],]\n          clusterech = hclust (dist (echantillon),method = \"ward.D2\")\n          r = rand(cutree(clusterpop,k)[nblinessample[i,]],cutree(clusterech,k))\n          \n          moy=(moy+(r/n))\n          \n        }\n        \n        moyenneRand[k]=moy\n        \n        \n      }\n      for(i in 1:kmax){ \n        \n        moyenneRandmat[1,i]=moyenneRand[i]\n        \n      }\n      \n      moyenneRandmat1[1,1] = which(moyenneRand==max(moyenneRand))[length( which(moyenneRand==max(moyenneRand)))]\n      \n    }else if(meth.class == \"Médianne\"){\n      \n      for(k in kmin:kmax){\n        \n        clusterpop = hclust (dist (data),method = \"median\")\n        moy = 0\n        for(i in 1:n){\n          \n          echantillon= data[nblinessample[i,],]\n          clusterech = hclust (dist (echantillon),method = \"median\")\n          r = rand(cutree(clusterpop,k)[nblinessample[i,]],cutree(clusterech,k))\n          \n          moy=(moy+(r/n))\n          \n        }\n        \n        moyenneRand[k]=moy\n        \n        \n      }\n      \n      for(i in 1:kmax){ \n        \n        moyenneRandmat[1,i]=moyenneRand[i]\n        \n      }\n      \n      moyenneRandmat1[1,1] = which(moyenneRand==max(moyenneRand))[length( which(moyenneRand==max(moyenneRand)))]\n      \n      \n    }\n    \n    if(meth.class == \"Kmeans\"){\n      \n      data.acp <- princomp(data)\n      \n      data.acp.km <- kmeans(data.acp$scores, moyenneRandmat1[1,1])\n      \n      return(c(meth.class,meth.ech,n,moyenneRandmat[,kmin:kmax],moyenneRandmat1))\n      \n      \n    }else{\n      \n      dend <- as.dendrogram(clusterpop)\n      return(c(meth.class,meth.ech,n,moyenneRandmat[,kmin:kmax],moyenneRandmat1))\n      \n      \n    }\n    \n    \n    \n  }\n  \n  data.input = reactive({\n    upload.data = try(data.frame(datainReg1()))\n    \n    df = data.frame(0)\n    nn = \"x1\"\n    for(i in 1:length(upload.data))\n    { if (is.numeric(upload.data[,i])){\n      df = try(data.frame(df,upload.data[,i]))\n      nn = try(c(nn, colnames(upload.data)[i]))\n    }\n    }\n    colnames(df)=nn\n    df = df[-1]\n    df\n    \n  })\n  \n  observeEvent(input$nbech,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Resultats\" ,\n                         \"Les classes\" = \"Resultats\" \n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n  })\n  \n  observeEvent(input$mthclass,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Resultats\" ,\n                         \"Les classes\" = \"Resultats\" \n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n  })\n  \n  observeEvent(input$mthech,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Resultats\" ,\n                         \"Les classes\" = \"Resultats\" \n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n  })\n  \n  observeEvent(input$choik,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Resultats\" ,\n                         \"Les classes\" = \"Resultats\" \n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n  })\n  observeEvent(input$tau,{\n    \n    rm(list=ls())\n    environment= environment()\n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Resultats\" ,\n                         \"Les classes\" = \"Resultats\" \n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n  })\n  \n  observeEvent(input$fildtp,{\n    rm(list=ls())\n    environment= environment()\n    \n    \n    nextabclass = switch(input$class1,\n                         \"Plot des classes\" = \"Data Upload\" ,\n                         \"Les classes\" = \"Data Upload\" ,\n                         \"Resultats\" = \"Data Upload\"  , \n                         \"Methode d'utilisation\" = \"Data Upload\", \n                         \"Documentation\" = \"Data Upload\"\n    )\n    \n    updateTabItems(session,\"class1\",nextabclass)\n    \n    \n  })\n  \n  \n  observeEvent(input$sbmitclass,{\n    \n    if(is.null(input$fildtp)){\n      toggleModal(session, \"supplyclass\", toggle =\"close\")\n    }else{\n      \n      rm(list=ls())\n      environment= environment()\n      \n      nextabclass = switch(input$class1,\n                           \"Plot des classes\" = \"Resultats\" ,\n                           \"Les classes\" = \"Resultats\" ,\n                           \"Data Upload\" = \"Resultats\", \n                           \"Methode d'utilisation\" = \"Resultats\", \n                           \"Documentation\" = \"Resultats\"\n      )\n      \n      updateTabItems(session,\"class1\",nextabclass)\n      \n      \n      \n      output$ss=renderDataTable({\n        \n        data.input = try(data.frame(data.input()))\n        \n        p = try(koptimal(data.input,input$nbech,input$tau/100,input$choik[1],input$choik[2],input$mthclass,input$mthech))\n        if(class(p)==\"try-error\"){\n          toggleModal(session, \"emptyclass\", toggle =\"close\")\n          return()\n        }else{\n          c = as.numeric(input$choik[2])-as.numeric(input$choik[1])\n          o = p[[(4+c+1)]]\n          updateNumericInput(session,\"nbclass\",value = 1,min=1,max = o)\n          \n          if(input$choik[1]==input$choik[2]){\n            \n            output$ss1 = renderText({\n              \n              paste(\"Le nombre de classes choisi :\",p[[(4+c+1)]])\n              \n              \n            })\n            \n            output$ss2 = renderText({\n              \n              paste(\"La méthode de classification :\",p[[1]])\n              \n              \n            })\n            \n            output$ss3 = renderText({\n              \n              return(NULL)\n              \n              \n            })\n            \n            output$ss4 = renderText({\n              \n              return(NULL)\n              \n              \n            })\n          }else{\n            \n            output$ss1 = renderText({\n              \n              paste(\"Le nombre de classes optimal :\",p[[(4+c+1)]])\n              \n              \n            })\n            \n            output$ss2 = renderText({\n              \n              paste(\"La méthode de classification :\",p[[1]])\n              \n              \n            })\n            \n            output$ss3 = renderText({\n              \n              paste(\"La méthode d'échantillonage :\",p[[2]])\n              \n              \n            })\n            \n            output$ss4 = renderText({\n              \n              paste(\"Le nombre d'echantillons utilisés :\",p[[3]])\n              \n              \n            })\n          }\n          \n          output$plott2 = renderPlot({\n            if(input$mthclass == \"Kmeans\"){\n              \n              p = autoplot(pam(data.input,p[[(4+c+1)]]), frame = TRUE, frame.type = 'norm',label = TRUE,label.size = 3)+\n                ggtitle(\"les classes \\n Méthode : Kmeans\")+ theme(\n                  plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))\n              \n            }else if(input$mthclass == \"Moyenne\"){\n              dend <- data.input%>% scale %>% dist %>% \n                hclust(\"average\") %>% as.dendrogram %>%\n                set(\"branches_k_color\", k=o) %>% set(\"branches_lwd\", 1)%>% set(\"labels_col\", k=o)\n              \n              ggd1 <- as.ggdend(dend)\n              if(input$hor == \"non\"){\n                p = ggplot(ggd1, horiz = F, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Moyenne\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))\n              }else{\n                p = ggplot(ggd1, horiz = T, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Moyenne\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))}\n              \n            }else if(input$mthclass == \"Médianne\"){\n              dend <- data.input%>% scale %>% dist %>% \n                hclust(\"median\") %>% as.dendrogram %>%\n                set(\"branches_k_color\", k=o) %>% set(\"branches_lwd\", 1)%>%  set(\"labels_col\", k=o)\n              \n              ggd1 <- as.ggdend(dend)\n              if(input$hor == \"non\"){\n                p = ggplot(ggd1, horiz = F, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Médianne\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5)) \n              }else{\n                p =  ggplot(ggd1, horiz = T, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Médianne\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))}\n              \n            }else if(input$mthclass == \"Complète\"){\n              dend <- data.input%>% scale %>% dist %>% \n                hclust(\"complete\") %>% as.dendrogram %>%\n                set(\"branches_k_color\", k=o) %>% set(\"branches_lwd\", 1)%>%  set(\"labels_col\", k=o)\n              \n              ggd1 <- as.ggdend(dend)\n              if(input$hor == \"non\"){\n                p = ggplot(ggd1, horiz = F, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Complète\") + theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))\n              }else{\n                p = ggplot(ggd1, horiz = T, theme = theme_minimal())+\n                  ggtitle(\"Dendogramme \\n Méthode : Complète\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))}\n              \n            }else if(input$mthclass == \"Hiérarchique\"){\n              \n              \n              dend <- data.input%>% scale %>% dist %>% \n                hclust(\"ward.D2\") %>% as.dendrogram %>%\n                set(\"branches_k_color\", k=o) %>% set(\"branches_lwd\", 1)%>%  set(\"labels_col\", k=o)\n              \n              ggd1 <- as.ggdend(dend)\n              if(input$hor == \"non\"){\n                p = ggplot(ggd1, horiz = F, theme = theme_minimal()) +\n                  ggtitle(\"Dendogramme \\n Méthode : Hiérarchique\")+ theme(\n                    plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))\n              }else{p = ggplot(ggd1, horiz = T, theme = theme_minimal())+\n                ggtitle(\"Dendogramme \\n Méthode : Hiérarchique\")+ theme(\n                  plot.title = element_text(color=\"blue\", size=14, face=\"bold.italic\",hjust = 0.5))}\n            }\n            \n            output$pltclass = downloadHandler(\n              filename = 'plot des classes.png',\n              content = function(file) {\n                device <- function(..., width, height) {\n                  grDevices::png(..., width = width, height = height,\n                                 res = 300, units = \"in\")\n                }\n                ggsave(file, plot = p, device = device)\n              })\n            p\n            \n          })\n          \n          \n          \n          output$sss = renderDataTable({\n            \n            if(input$mthclass == \"Kmeans\"){ \n              y<-kmeans(data.input,o)\n              \n              classe <-y$cluster\n              dd = data.frame(datainReg1())\n              \n              dd <-cbind(dd ,classe)\n              \n              x1<- subset(dd , classe == input$nbclass)\n              size1 = nrow(x1)\n              \n            }else if(input$mthclass == \"Hiérarchique\"){\n              \n              y<-dist(data.input)\n              clust<-hclust(y,method = \"ward.D2\")\n              classe <-cutree(clust, k=o)\n              dd = data.frame(datainReg1())\n              \n              dd <-cbind(dd ,classe)\n              \n              x1<- subset(dd , classe == input$nbclass)\n              size1 = nrow(x1)\n              \n            }else if(input$mthclass == \"Moyenne\"){\n              \n              y<-dist(data.input)\n              clust<-hclust(y,method = \"average\")\n              classe <-cutree(clust, k=o)\n              dd = data.frame(datainReg1())\n              \n              dd <-cbind(dd ,classe)\n              \n              x1<- subset(dd , classe == input$nbclass)\n              size1 = nrow(x1)\n              \n            }else if(input$mthclass == \"Médianne\"){\n              \n              y<-dist(data.input)\n              clust<-hclust(y,method = \"median\")\n              classe <-cutree(clust, k=o)\n              dd = data.frame(datainReg1())\n              \n              dd <-cbind(dd ,classe)\n              \n              x1<- subset(dd , classe == input$nbclass)\n              size1 = nrow(x1)\n              \n            }else if(input$mthclass == \"Complète\"){\n              \n              y<-dist(data.input)\n              clust<-hclust(y,method = \"complete\")\n              classe <-cutree(clust, k=o)\n              dd = data.frame(datainReg1())\n              \n              dd <-cbind(dd ,classe)\n              \n              x1<- subset(dd , classe == input$nbclass)\n              size1 = nrow(x1)\n            }\n            \n            output$size = renderText({\n              paste(\"La taille de la classe :\",size1)\n            })\n            \n            datatable(data.frame(x1),  class = 'cell-border stripe',caption = 'Classe',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n              \n              columnDefs = list(list(className = 'dt-center')),\n              buttons = \n                list('copy', 'print', list(\n                  extend = 'collection',\n                  buttons = c('csv', 'excel', 'pdf'),\n                  text = 'Download'\n                )),\n              initComplete = JS(\n                \"function(settings, json) {\",\n                \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n                \"}\"),\n              colReorder = TRUE\n            )\n            )\n            \n          })\n          \n          df = data.frame(p[4:(4+c)])\n          \n          rownames(df)=\"moyennes des indices de Rand\"\n          for(i in 4:(4+c)){\n            colnames(df)[i-3]=names(p[i])\n          }\n          \n          for(i in 1:length(df)){\n            df[1,i] = format(as.numeric(df[1,i]),scientific = T)\n          }\n          \n          \n          datatable(df,  class = 'cell-border stripe',caption = 'Moyennes des indices de Rand',  extensions = c('Buttons','ColReorder','Responsive'), options = list(\n            dom = 'Bt',\n            columnDefs = list(list(className = 'dt-center')),\n            buttons = \n              list('copy', 'print', list(\n                extend = 'collection',\n                buttons = c('csv', 'excel', 'pdf'),\n                text = 'Download'\n              )),\n            initComplete = JS(\n              \"function(settings, json) {\",\n              \"$(this.api().table().header()).css({'background-color': '#222d32', 'color': '#fff'});\",\n              \"}\"),\n            colReorder = TRUE\n          )\n          )\n          \n        }\n        \n      })\n      withProgress(message = 'Chargement en cours ...',\n                   value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.1)\n                     }\n                     \n                   })\n    }\n  })\n  \n  \n  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END classification TEST~~~~~~~~~~~~~~~~~~~~~~~~~~#\n  \n  \n  output$videoReg = renderUI({\n    embed_url(\"https://www.youtube.com/watch?v=Xh6Rex3ARjc\")\n  })\n  \n  output$videoClass = renderUI({\n    embed_url(\"https://www.youtube.com/watch?v=ImbXdYrT59s\")\n  })\n  \n  output$videoACP = renderUI({\n    embed_url(\"https://www.youtube.com/watch?v=1QPRsg3Bxok\")\n  })\n  \n  output$iris <- downloadHandler(\n    filename = function() {\n      paste(\"iris-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(iris, file,row.names=FALSE,col.names=TRUE,sep=\";\")\n    }\n  )\n  \n  output$decathlon <- downloadHandler(\n    filename = function() {\n      paste(\"decathlon-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(decathlon, file,row.names=FALSE,col.names=TRUE,sep=\";\")\n    }\n  )\n  \n  output$uscereal <- downloadHandler(\n    filename = function() {\n      paste(\"UScereal-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(UScereal, file,row.names=FALSE,col.names=TRUE,sep=\";\")\n    }\n  )\n  \n})",
    "created" : 1514824337091.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2250424259",
    "id" : "C684EFA9",
    "lastKnownWriteTime" : 1514824623,
    "last_content_update" : 1514824623,
    "path" : "C:/Users/Lenovo/Desktop/chiheb/3eme/projet shiny/Chiheb Nakkachi/Chiheb Nakkachi.Rproj",
    "project_path" : "Chiheb Nakkachi.Rproj",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "text"
}